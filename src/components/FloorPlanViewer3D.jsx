import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
// æ‹¡å¼µå­ .js ã‚’æ˜ç¤ºçš„ã«è¿½åŠ ã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’å›é¿
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

/**
 * é–“å–ã‚Šãƒ‡ãƒ¼ã‚¿ (JSON) ã‚’å—ã‘å–ã£ã¦3Dè¡¨ç¤ºã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * @param {Object} props
 * @param {Object} [props.initialData] - åˆæœŸè¡¨ç¤ºã™ã‚‹é–“å–ã‚ŠJSONãƒ‡ãƒ¼ã‚¿ (çœç•¥å¯)
 */
const FloorPlanViewer3D = ({ initialData = null, onClose }) => {
  const mountRef = useRef(null);
  const miniMapRef = useRef(null);

  // Three.js ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¿æŒç”¨
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const controlsRef = useRef(null);
  const objectGroupRef = useRef(null);
  const wallGroupRef = useRef(null);
  const requestRef = useRef(null);

  // ãƒ‡ãƒ¼ã‚¿ç®¡ç†ç”¨Ref
  const centerMmRef = useRef({ x: 0, y: 0 });
  const dataBoundsRef = useRef({ minX: 0, maxX: 1000, minY: 0, maxY: 1000 });
  const floorPlanDataRef = useRef(initialData);

  // ç§»å‹•ç”¨ã‚­ãƒ¼çŠ¶æ…‹ç®¡ç†
  const keysPressed = useRef({});
  // ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ç®¡ç† (æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ç”¨)
  const isDraggingRef = useRef(false);
  const previousMousePositionRef = useRef({ x: 0, y: 0 });

  // ã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†
  const [floorPlanData, setFloorPlanData] = useState(initialData);
  const [wallHeight, setWallHeight] = useState(2400);
  const [wallOpacity, setWallOpacity] = useState(1.0);
  const [isWalkMode, setIsWalkMode] = useState(false);
  const [isMenuOpen, setIsMenuOpen] = useState(true); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‹é–‰çŠ¶æ…‹
  const [sceneInitialized, setSceneInitialized] = useState(false); // ã‚·ãƒ¼ãƒ³åˆæœŸåŒ–å®Œäº†ãƒ•ãƒ©ã‚°

  // å®šæ•°
  const MM_TO_SCENE = 0.01; // 100mm = 1 unit
  const DATA_SCALE = 5.0;   // ãƒ‡ãƒ¼ã‚¿ã®åº§æ¨™è£œæ­£å€¤
  const WALL_THICKNESS = 120 * MM_TO_SCENE;
  const EYE_LEVEL = 1500 * MM_TO_SCENE; // ç›®ã®é«˜ã• 1.5m

  const COLORS = {
    floor: {
      default: 0xffffff,
      bath: 0xaaccff,
      wash: 0xddeeff,
      toilet: 0xffffee,
      entrance: 0xdddddd,
      western: 0xf5f5dc,
      storage: 0xeeeeee,
      ldk: 0xfffcf0,
      corridor: 0xfafafa
    },
    wall: 0xeeeeee,
    furniture: 0x8B4513,
    kitchen: 0x808080,
    sofa: 0x556B2F,
    window: 0x87CEEB,
    door: 0x8B4513
  };

  // --- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š ---
  useEffect(() => {
    const handleKeyDown = (e) => { keysPressed.current[e.code] = true; };
    const handleKeyUp = (e) => { keysPressed.current[e.code] = false; };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // --- åˆæœŸåŒ–å‡¦ç† (ãƒã‚¦ãƒ³ãƒˆæ™‚) ---
  useEffect(() => {
    if (!mountRef.current) return;

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    // ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã«æš—ããªã‚‰ãªã„ã‚ˆã†ã«ãƒ•ã‚©ã‚°ã®è·é›¢ã‚’èª¿æ•´
    scene.fog = new THREE.Fog(0x333333, 200, 1000);
    sceneRef.current = scene;

    // Group
    const objectGroup = new THREE.Group();
    const wallGroup = new THREE.Group();
    scene.add(objectGroup);
    scene.add(wallGroup);
    objectGroupRef.current = objectGroup;
    wallGroupRef.current = wallGroup;

    // Camera
    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 50, 60);
    // ã‚«ãƒ¡ãƒ©ã®å›è»¢é †åºã‚’YXZï¼ˆæ°´å¹³å›è»¢ã—ã¦ã‹ã‚‰å‚ç›´å›è»¢ï¼‰ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€FPSè¦–ç‚¹ã®æŒ™å‹•ã‚’å®‰å®šã•ã›ã‚‹
    camera.rotation.order = 'YXZ';
    cameraRef.current = camera;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’è¦ªè¦ç´ å†…ã«æ­£ã—ãé…ç½®ã™ã‚‹ãŸã‚ã®ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';

    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controlsRef.current = controls;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(20, 50, 30);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.left = -60;
    dirLight.shadow.camera.right = 60;
    dirLight.shadow.camera.top = 60;
    dirLight.shadow.camera.bottom = -60;
    scene.add(dirLight);

    // â˜…ä¿®æ­£: ResizeObserverã‚’ä½¿ç”¨ã—ã¦ã€ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’æ­£ç¢ºã«æ¤œçŸ¥ã™ã‚‹
    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        if (entry.target === mountRef.current && cameraRef.current && rendererRef.current) {
          const { width, height } = entry.contentRect;
          // ã‚µã‚¤ã‚ºãŒ0ã®å ´åˆã¯å‡¦ç†ã—ãªã„ï¼ˆã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
          if (width === 0 || height === 0) return;

          cameraRef.current.aspect = width / height;
          cameraRef.current.updateProjectionMatrix();
          rendererRef.current.setSize(width, height);
        }
      }
    });

    // ç›£è¦–é–‹å§‹
    resizeObserver.observe(mountRef.current);

    // ã‚·ãƒ¼ãƒ³åˆæœŸåŒ–å®Œäº†ã‚’é€šçŸ¥
    setSceneInitialized(true);

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    return () => {
      resizeObserver.disconnect();
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current);
      }
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
      setSceneInitialized(false);
    };
  }, []);

  const isWalkModeRef = useRef(isWalkMode);

  // --- ãƒã‚¦ã‚¹æ“ä½œï¼ˆæ­©è¡Œãƒ¢ãƒ¼ãƒ‰ç”¨ï¼šè‡ªå‰LookAroundï¼‰ ---
  useEffect(() => {
    const handleMouseDown = (e) => {
      if (!isWalkModeRef.current) return;
      isDraggingRef.current = true;
      previousMousePositionRef.current = { x: e.clientX, y: e.clientY };
    };

    const handleMouseMove = (e) => {
      if (!isWalkModeRef.current || !isDraggingRef.current || !cameraRef.current) return;

      const deltaX = e.clientX - previousMousePositionRef.current.x;
      const deltaY = e.clientY - previousMousePositionRef.current.y;

      previousMousePositionRef.current = { x: e.clientX, y: e.clientY };

      const camera = cameraRef.current;
      const rotateSpeed = 0.002;

      // Yè»¸ï¼ˆå·¦å³ï¼‰å›è»¢: ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã§å›ã™
      camera.rotation.y -= deltaX * rotateSpeed;

      // Xè»¸ï¼ˆä¸Šä¸‹ï¼‰å›è»¢: åˆ¶é™ä»˜ã
      camera.rotation.x -= deltaY * rotateSpeed;
      // é¦–ã®è§’åº¦åˆ¶é™ï¼ˆä¸Šå‘ãã™ããƒ»ä¸‹å‘ãã™ãé˜²æ­¢: ç´„85åº¦ï¼‰
      const maxPolarAngle = Math.PI / 2 - 0.1;
      camera.rotation.x = Math.max(-maxPolarAngle, Math.min(maxPolarAngle, camera.rotation.x));

      // Zè»¸å›è»¢ï¼ˆå‚¾ãï¼‰ã¯ã‚¼ãƒ­ã«ä¿ã¤
      camera.rotation.z = 0;
    };

    const handleMouseUp = () => {
      isDraggingRef.current = false;
    };

    // Canvasè¦ç´ ã«å¯¾ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã¤ã‘ã‚‹ã®ãŒç†æƒ³ã ãŒã€ç°¡å˜ã®ãŸã‚windowã«
    const canvas = rendererRef.current?.domElement;
    if (canvas) {
      canvas.addEventListener('mousedown', handleMouseDown);
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      if (canvas) {
        canvas.removeEventListener('mousedown', handleMouseDown);
      }
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, []);

  // --- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆãƒ›ã‚¤ãƒ¼ãƒ«ï¼‰ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š ---
  useEffect(() => {
    const handleWheel = (e) => {
      if (!isWalkModeRef.current || !cameraRef.current) return;

      // æ­©è¡Œãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç„¡åŠ¹åŒ–ã—ã¦ã„ã‚‹ã®ã§è‡ªå‰ã§ç§»å‹•
      const sensitivity = 0.03;
      const moveDistance = -e.deltaY * sensitivity;

      const cam = cameraRef.current;
      const forward = new THREE.Vector3();
      cam.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      if (forward.lengthSq() === 0) return;

      const move = forward.multiplyScalar(moveDistance);
      cam.position.add(move);
      // OrbitControlsãŒç„¡åŠ¹ãªã®ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ›´æ–°ã¯ä¸è¦
    };
    window.addEventListener('wheel', handleWheel);
    return () => {
      window.removeEventListener('wheel', handleWheel);
    };
  }, []);

  useEffect(() => {
    isWalkModeRef.current = isWalkMode;

    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ã‚«ãƒ¡ãƒ©åˆ¶å¾¡
    if (controlsRef.current && cameraRef.current) {
      const ctrl = controlsRef.current;
      const cam = cameraRef.current;

      if (isWalkMode) {
        // --- æ­©è¡Œãƒ¢ãƒ¼ãƒ‰é–‹å§‹ ---

        // 1. OrbitControls ã‚’ç„¡åŠ¹åŒ–ï¼ˆå¹²æ¸‰ã‚’é˜²ãï¼‰
        ctrl.enabled = false;

        // 2. ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«ã‚«ãƒ¡ãƒ©ã‚’ç§»å‹•ã•ã›ã€é«˜ã•ã‚’åˆã‚ã›ã‚‹
        const target = ctrl.target.clone();

        // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ã‹ã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®ãƒ™ã‚¯ãƒˆãƒ«
        const vec = new THREE.Vector3().subVectors(target, cam.position);
        vec.y = 0; // æ°´å¹³è·é›¢ã®ã¿
        const dist = vec.length();

        // ã‚‚ã—é ã™ããŸã‚‰è¿‘ã¥ã‘ã‚‹ã€è¿‘ã™ããŸã‚‰ãã®ã¾ã¾
        if (dist > 10) {
          vec.normalize().multiplyScalar(dist - 10);
          cam.position.add(vec);
        }
        cam.position.y = EYE_LEVEL;

        // 3. ã‚«ãƒ¡ãƒ©ã®è§’åº¦ï¼ˆRotationï¼‰ã‚’èª¿æ•´
        cam.lookAt(target.x, EYE_LEVEL, target.z);

      } else {
        // --- æ­©è¡Œãƒ¢ãƒ¼ãƒ‰çµ‚äº†ï¼ˆä¿¯ç°ã«æˆ»ã‚‹ï¼‰ ---

        // 1. ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ä½ç½®ã¨å‘ãã‹ã‚‰ã€æ–°ã—ã„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆæ³¨è¦–ç‚¹ï¼‰ã‚’è¨ˆç®—
        const forward = new THREE.Vector3();
        cam.getWorldDirection(forward);

        const newTarget = cam.position.clone().add(forward.multiplyScalar(20));
        newTarget.y = 0; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯åºŠãƒ¬ãƒ™ãƒ«ã«

        // 2. ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å¼•ãä¸Šã’ã‚‹ï¼ˆä¿¯ç°ãƒã‚¸ã‚·ãƒ§ãƒ³ã¸ï¼‰
        const back = new THREE.Vector3();
        cam.getWorldDirection(back);
        back.y = 0;
        back.normalize().negate(); // å¾Œã‚æ–¹å‘

        cam.position.add(back.multiplyScalar(30)); // 30ä¸‹ãŒã‚‹
        cam.position.y = 50; // é«˜ã•ç¢ºä¿

        // 3. OrbitControls ã‚’æœ‰åŠ¹åŒ–ãƒ»æ›´æ–°
        ctrl.target.copy(newTarget);
        ctrl.enabled = true;
        ctrl.update();
      }
    }
  }, [isWalkMode]);

  // ãƒŸãƒ‹ãƒãƒƒãƒ—æç”»é–¢æ•°
  const drawMiniMap = () => {
    const canvas = miniMapRef.current;
    if (!canvas || !isWalkModeRef.current) return;

    const currentData = floorPlanDataRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
    ctx.fillRect(0, 0, width, height);

    if (!currentData) {
      ctx.fillStyle = "#666";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("No Data", width / 2, height / 2);
      return;
    }

    const bounds = dataBoundsRef.current;
    const dataW = bounds.maxX - bounds.minX;
    const dataH = bounds.maxY - bounds.minY;
    if (dataW === 0 || dataH === 0) return;

    const margin = 20;
    const drawW = width - margin * 2;
    const drawH = height - margin * 2;

    const scaleX = drawW / dataW;
    const scaleY = drawH / dataH;
    const scale = Math.min(scaleX, scaleY);

    const offsetX = margin + (drawW - dataW * scale) / 2;
    const offsetY = margin + (drawH - dataH * scale) / 2;

    const toCanvasX = (x) => offsetX + (x - bounds.minX) * scale;
    const toCanvasY = (y) => offsetY + (y - bounds.minY) * scale;

    if (currentData.rooms) {
      currentData.rooms.forEach(room => {
        let colorHex = "#e0e0e0";
        if (room.type && COLORS.floor[room.type]) {
          colorHex = '#' + COLORS.floor[room.type].toString(16).padStart(6, '0');
        } else if (room.type === 'free' && room.customLabel === 'WIC') {
          colorHex = '#' + COLORS.floor.storage.toString(16).padStart(6, '0');
        }
        if (colorHex.toLowerCase() === '#ffffff') colorHex = '#f0f0f0';

        ctx.beginPath();
        room.points.forEach((p, i) => {
          const cx = toCanvasX(p.x);
          const cy = toCanvasY(p.y);
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        });
        ctx.closePath();
        ctx.fillStyle = colorHex;
        ctx.fill();
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

    if (cameraRef.current) {
      const cam = cameraRef.current;
      const centerMm = centerMmRef.current;
      const rawX = (cam.position.x / MM_TO_SCENE + centerMm.x) / DATA_SCALE;
      const rawY = (cam.position.z / MM_TO_SCENE + centerMm.y) / DATA_SCALE;
      const myCx = toCanvasX(rawX);
      const myCy = toCanvasY(rawY);

      const dir = new THREE.Vector3();
      cam.getWorldDirection(dir);
      const angle = Math.atan2(dir.z, dir.x);

      ctx.save();
      ctx.translate(myCx, myCy);
      ctx.rotate(angle);

      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(-7, 6);
      ctx.lineTo(-7, -6);
      ctx.closePath();
      ctx.fillStyle = "#ff0000";
      ctx.fill();
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();

      ctx.beginPath();
      ctx.arc(myCx, myCy, 4, 0, Math.PI * 2);
      ctx.fillStyle = "#ff0000";
      ctx.fill();
      ctx.stroke();
    }
  };

  // â˜…è¿½åŠ : ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©
  const handleMiniMapClick = (e) => {
    // æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ã‹ã¤ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã®ã¿
    if (!isWalkModeRef.current || !floorPlanDataRef.current || !cameraRef.current) return;

    // Canvasä¸Šã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®
    const rect = e.target.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»ã‚ªãƒ•ã‚»ãƒƒãƒˆå†è¨ˆç®— (drawMiniMapã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯)
    const canvas = miniMapRef.current;
    const bounds = dataBoundsRef.current;
    const dataW = bounds.maxX - bounds.minX;
    const dataH = bounds.maxY - bounds.minY;
    if (dataW === 0 || dataH === 0) return;

    const margin = 20;
    const drawW = canvas.width - margin * 2;
    const drawH = canvas.height - margin * 2;

    const scaleX = drawW / dataW;
    const scaleY = drawH / dataH;
    const scale = Math.min(scaleX, scaleY);

    const offsetX = margin + (drawW - dataW * scale) / 2;
    const offsetY = margin + (drawH - dataH * scale) / 2;

    // Canvasåº§æ¨™ -> ãƒ‡ãƒ¼ã‚¿åº§æ¨™(raw) -> 3Dåº§æ¨™
    // x = (canvasX - offsetX) / scale + bounds.minX
    const rawX = (clickX - offsetX) / scale + bounds.minX;
    const rawY = (clickY - offsetY) / scale + bounds.minY;

    // ãƒ‡ãƒ¼ã‚¿åº§æ¨™ -> 3Dåº§æ¨™
    // 3D X = (rawX * DATA_SCALE - center.x) * MM_TO_SCENE
    const centerMm = centerMmRef.current;
    const targetX = (rawX * DATA_SCALE - centerMm.x) * MM_TO_SCENE;
    const targetZ = (rawY * DATA_SCALE - centerMm.y) * MM_TO_SCENE;

    // ã‚«ãƒ¡ãƒ©ç§»å‹•
    const cam = cameraRef.current;
    cam.position.x = targetX;
    cam.position.z = targetZ;

    // å³æ™‚å†æç”»
    drawMiniMap();
  };


  useEffect(() => {
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—æœ¬ä½“
    const animate = () => {
      requestRef.current = requestAnimationFrame(animate);

      const cam = cameraRef.current;

      // æ­©è¡Œãƒ¢ãƒ¼ãƒ‰æ™‚ã®ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯
      if (cam && isWalkModeRef.current) {
        const moveSpeed = 0.5;
        const forward = new THREE.Vector3();
        cam.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        const move = new THREE.Vector3(0, 0, 0);
        if (keysPressed.current['KeyW'] || keysPressed.current['ArrowUp']) move.add(forward);
        if (keysPressed.current['KeyS'] || keysPressed.current['ArrowDown']) move.sub(forward);
        if (keysPressed.current['KeyA'] || keysPressed.current['ArrowLeft']) move.sub(right);
        if (keysPressed.current['KeyD'] || keysPressed.current['ArrowRight']) move.add(right);

        if (move.lengthSq() > 0) {
          move.normalize().multiplyScalar(moveSpeed);
          cam.position.add(move);
        }

        drawMiniMap();
      } else {
        // ä¿¯ç°ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯Controlsã‚’æ›´æ–°
        if (controlsRef.current) controlsRef.current.update();
      }

      if (rendererRef.current && sceneRef.current && cam) {
        // æœ€åˆã®æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ã ã‘ãƒ­ã‚°ã‚’å‡ºåŠ›
        if (!window._3dDebugFrameCount) window._3dDebugFrameCount = 0;
        if (window._3dDebugFrameCount < 3) {
          console.log('[3D DEBUG] Rendering frame', window._3dDebugFrameCount, {
            sceneChildren: sceneRef.current.children.length,
            cameraPos: cam.position,
            cameraTarget: controlsRef.current?.target,
            rendererSize: { width: rendererRef.current.domElement.width, height: rendererRef.current.domElement.height }
          });
          window._3dDebugFrameCount++;
        }
        rendererRef.current.render(sceneRef.current, cam);
      }
    };

    if (requestRef.current) cancelAnimationFrame(requestRef.current);
    animate();

    return () => {
      cancelAnimationFrame(requestRef.current);
    };
  }, []);


  // --- ã‚·ãƒ¼ãƒ³æ§‹ç¯‰ ---
  useEffect(() => {
    floorPlanDataRef.current = floorPlanData;
    if (!floorPlanData || !sceneRef.current || !sceneInitialized) {
      return;
    }
    rebuildScene(floorPlanData);
  }, [floorPlanData, wallHeight, wallOpacity, sceneInitialized]);


  // ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ä¸­å¿ƒåº§æ¨™ã¨ç¯„å›²ã‚’è¨ˆç®— (mmå˜ä½)
  const calcDataBounds = (data) => {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    if (!data.rooms || data.rooms.length === 0) return { x: 0, y: 0 };

    data.rooms.forEach(room => {
      room.points.forEach(p => {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      });
    });

    if (minX === Infinity) { minX = 0; maxX = 0; minY = 0; maxY = 0; }
    dataBoundsRef.current = { minX, maxX, minY, maxY };

    return {
      x: (minX + maxX) / 2 * DATA_SCALE,
      y: (minY + maxY) / 2 * DATA_SCALE
    };
  };

  const clearGroups = () => {
    if (objectGroupRef.current) {
      while (objectGroupRef.current.children.length > 0) {
        const child = objectGroupRef.current.children[0];
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
          else child.material.dispose();
        }
        objectGroupRef.current.remove(child);
      }
    }
    if (wallGroupRef.current) {
      while (wallGroupRef.current.children.length > 0) {
        const child = wallGroupRef.current.children[0];
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
          else child.material.dispose();
        }
        wallGroupRef.current.remove(child);
      }
    }
  };

  const rebuildScene = (data) => {
    clearGroups();
    const centerMm = calcDataBounds(data);
    centerMmRef.current = centerMm;
    buildWalls(data, centerMm);
    buildFloorsAndObjects(data, centerMm);

    // ã‚«ãƒ¡ãƒ©ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚·ãƒ¼ãƒ³ã®ä¸­å¿ƒã«è¨­å®šï¼ˆã“ã‚ŒãŒãªã„ã¨åºŠãŒè¦‹ãˆãªã„ï¼‰
    if (controlsRef.current && !isWalkModeRef.current && cameraRef.current) {
      // ã‚«ãƒ¡ãƒ©ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’åŸç‚¹ã«
      controlsRef.current.target.set(0, 0, 0);

      // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚‚ãƒªã‚»ãƒƒãƒˆï¼ˆåºŠã‚’è¦‹ã‚„ã™ã„ä½ç½®ã«ï¼‰
      cameraRef.current.position.set(0, 50, 60);

      controlsRef.current.update();
    }
  };

  const buildWalls = (data, center) => {
    if (!data.walls) return;
    const currentWallHeight = wallHeight * MM_TO_SCENE;
    const isTransparent = wallOpacity < 1.0;
    const wallMat = new THREE.MeshLambertMaterial({
      color: COLORS.wall,
      transparent: isTransparent,
      opacity: wallOpacity,
      depthWrite: !isTransparent
    });

    data.walls.forEach(wall => {
      const sx = (wall.start.x * DATA_SCALE - center.x) * MM_TO_SCENE;
      const sz = (wall.start.y * DATA_SCALE - center.y) * MM_TO_SCENE;
      const ex = (wall.end.x * DATA_SCALE - center.x) * MM_TO_SCENE;
      const ez = (wall.end.y * DATA_SCALE - center.y) * MM_TO_SCENE;
      const dist = Math.sqrt((ex - sx) ** 2 + (ez - sz) ** 2);
      const angle = Math.atan2(ez - sz, ex - sx);

      const geometry = new THREE.BoxGeometry(dist, currentWallHeight, WALL_THICKNESS);
      const mesh = new THREE.Mesh(geometry, wallMat);
      mesh.position.set((sx + ex) / 2, currentWallHeight / 2, (sz + ez) / 2);
      mesh.rotation.y = -angle;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      wallGroupRef.current.add(mesh);
    });
  };

  const buildFloorsAndObjects = (data, center) => {
    if (data.rooms) {
      data.rooms.forEach(room => {
        const shape = new THREE.Shape();
        room.points.forEach((p, index) => {
          const x = (p.x * DATA_SCALE - center.x) * MM_TO_SCENE;
          const z = (p.y * DATA_SCALE - center.y) * MM_TO_SCENE;
          if (index === 0) shape.moveTo(x, z);
          else shape.lineTo(x, z);
        });
        const geometry = new THREE.ShapeGeometry(shape);
        let color = COLORS.floor.default;
        if (room.type && COLORS.floor[room.type]) {
          color = COLORS.floor[room.type];
        } else if (room.type === 'free' && room.customLabel === 'WIC') {
          color = COLORS.floor.storage;
        }
        const material = new THREE.MeshLambertMaterial({ color: color, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        objectGroupRef.current.add(mesh);
      });
    }

    if (data.objects) {
      data.objects.forEach(obj => {
        let objWidth = (obj.width || 500) * MM_TO_SCENE;
        let objDepth = (obj.height || 500) * MM_TO_SCENE;
        let objHeight = 50 * MM_TO_SCENE;
        let color = COLORS.furniture;
        let elevation = 0;
        let opacity = 1.0;
        let transparent = false;

        switch (obj.type) {
          case 'window':
          case 'fix_window':
            objHeight = 1100 * MM_TO_SCENE;
            elevation = 900 * MM_TO_SCENE;
            color = COLORS.window;
            opacity = 0.5;
            transparent = true;
            objDepth = WALL_THICKNESS * 1.5;
            break;
          case 'door':
          case 'sliding_door':
            objHeight = 2000 * MM_TO_SCENE;
            elevation = 0;
            color = COLORS.door;
            objDepth = WALL_THICKNESS * 1.2; // å£ã‚ˆã‚Šå°‘ã—åšãã—ã¦è¡¨ç¤ºã•ã›ã‚‹
            break;
          case 'kitchen':
            objHeight = 850 * MM_TO_SCENE;
            color = COLORS.kitchen;
            break;
          case 'bath':
            objHeight = 600 * MM_TO_SCENE;
            color = COLORS.floor.bath;
            opacity = 0.8;
            transparent = true;
            break;
          case 'wash_basin':
            objHeight = 800 * MM_TO_SCENE;
            color = 0xffffff;
            break;
          case 'toilet':
            objHeight = 450 * MM_TO_SCENE;
            color = 0xffffff;
            break;
          case 'refrigerator':
            objHeight = 1800 * MM_TO_SCENE;
            color = 0xeeeeee;
            break;
          case 'sofa':
            objHeight = 400 * MM_TO_SCENE;
            color = COLORS.sofa;
            break;
          case 'table':
          case 'desk':
            objHeight = 700 * MM_TO_SCENE;
            color = 0x8B4513;
            break;
          case 'tv_stand':
            objHeight = 400 * MM_TO_SCENE;
            break;
          case 'tv':
            objHeight = 650 * MM_TO_SCENE;
            elevation = 450 * MM_TO_SCENE;
            color = 0x111111;
            objDepth = 50 * MM_TO_SCENE;
            break;
          case 'storage':
          case 'custom':
            objHeight = 1800 * MM_TO_SCENE;
            if (obj.label) {
              if (obj.label.includes("æœº")) objHeight = 700 * MM_TO_SCENE;
              else if (obj.label.includes("å°")) objHeight = 800 * MM_TO_SCENE;
              else if (obj.label.includes("é´")) objHeight = 1000 * MM_TO_SCENE;
              else if (obj.label.includes("æ£š")) objHeight = 1800 * MM_TO_SCENE;
            }
            color = 0xdeb887;
            break;
          case 'column':
            objHeight = 2400 * MM_TO_SCENE;
            color = COLORS.wall;
            break;
          default:
            objHeight = 700 * MM_TO_SCENE;
        }

        const geometry = new THREE.BoxGeometry(objWidth, objHeight, objDepth);
        const material = new THREE.MeshLambertMaterial({ color: color, transparent: transparent, opacity: opacity });
        const mesh = new THREE.Mesh(geometry, material);
        const px = (obj.x - center.x) * MM_TO_SCENE;
        const pz = (obj.y - center.y) * MM_TO_SCENE;
        mesh.position.set(px, elevation + objHeight / 2, pz);
        if (obj.rotation) mesh.rotation.y = -obj.rotation * Math.PI / 180;
        mesh.castShadow = !transparent;
        mesh.receiveShadow = true;
        objectGroupRef.current.add(mesh);
      });
    }
  };

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const json = JSON.parse(event.target.result);
        setFloorPlanData(json);
      } catch (err) {
        alert("JSONãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        console.error(err);
      }
    };
    reader.readAsText(file);
  };

  return (
    <div className="relative w-full h-screen bg-gray-900 overflow-hidden text-gray-800">
      <div ref={mountRef} className="relative w-full h-full cursor-pointer"></div>
      <canvas
        ref={miniMapRef}
        width="200"
        height="200"
        onClick={handleMiniMapClick}
        className={`absolute bottom-4 right-4 rounded-lg shadow-lg border-2 border-white bg-white/90 transition-opacity duration-300 ${isWalkMode ? "opacity-100 cursor-pointer" : "opacity-0 pointer-events-none"}`}
      />

      {/* --- BACK TO 2D BUTTON (Always Visible) --- */}
      <button
        onClick={onClose}
        className="absolute top-4 left-4 py-2 px-4 bg-gray-600 text-white rounded-lg shadow-lg font-bold hover:bg-gray-700 transition-colors flex items-center justify-center gap-2"
        title="2Dç·¨é›†ã«æˆ»ã‚‹"
      >
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        2Dç·¨é›†ã«æˆ»ã‚‹
      </button>

      {/* --- MENU TOGGLE BUTTON (When Closed) --- */}
      {!isMenuOpen && (
        <button
          onClick={() => setIsMenuOpen(true)}
          className="absolute top-16 left-4 bg-white/90 p-2 rounded-lg shadow-lg hover:bg-white transition-colors"
          title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã"
        >
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </button>
      )}

      {/* --- CONTROL PANEL (Animated Slide) --- */}
      <div className={`absolute top-16 left-4 bg-white/95 p-4 rounded-lg shadow-xl max-w-xs max-h-[90vh] overflow-y-auto transition-transform duration-300 ${isMenuOpen ? "translate-x-0" : "-translate-x-[120%]"}`}>

        {/* Header with Close Button */}
        <div className="flex justify-between items-center border-b-2 border-gray-200 pb-2 mb-2">
          <h1 className="text-lg font-bold">3D é–“å–ã‚Šãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼</h1>
          <button
            onClick={() => setIsMenuOpen(false)}
            className="text-gray-500 hover:text-gray-800 p-1 rounded-full hover:bg-gray-100 transition-colors"
            title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        <div className="mb-4">
          <button
            onClick={() => setIsWalkMode(!isWalkMode)}
            className={`w-full py-2 px-4 rounded font-bold transition-colors ${isWalkMode
              ? "bg-green-600 text-white hover:bg-green-700"
              : "bg-blue-600 text-white hover:bg-blue-700"
              }`}
          >
            {isWalkMode ? "ğŸš¶â€â™‚ï¸ æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ä¸­ (çµ‚äº†)" : "ğŸ¦… ä¿¯ç°ãƒ¢ãƒ¼ãƒ‰ (æ­©ã)"}
          </button>
          <p className="text-xs text-gray-600 mt-1">
            {isWalkMode
              ? "ç§»å‹•: WASD / çŸ¢å° / ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«\nè¦–ç‚¹: ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°\nãƒŸãƒ‹ãƒãƒƒãƒ—: ã‚¯ãƒªãƒƒã‚¯ã§ç§»å‹•"
              : "æ“ä½œ: å›è»¢ / ã‚ºãƒ¼ãƒ  / ç§»å‹•"
            }
          </p>
        </div>
        <div className="border-t border-gray-100 pt-3 mt-2">
          <div className="mb-3">
            <label className="block text-sm font-bold mb-1">
              å£ã®é«˜ã•: {wallHeight}mm
            </label>
            <input
              type="range"
              min="500" max="4000" step="100"
              value={wallHeight}
              onChange={(e) => setWallHeight(parseInt(e.target.value))}
              className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
          </div>
          <div className="mb-3">
            <label className="block text-sm font-bold mb-1">
              å£ã®é€æ˜åº¦: {wallOpacity}
            </label>
            <input
              type="range"
              min="0.1" max="1.0" step="0.1"
              value={wallOpacity}
              onChange={(e) => setWallOpacity(parseFloat(e.target.value))}
              className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
          </div>
          <div className="mb-3">
            <label className="block text-sm font-bold mb-1">ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿</label>
            <input
              type="file"
              accept=".json"
              onChange={handleFileChange}
              className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
            />
          </div>
        </div>
        <div className="mt-4 bg-gray-50 p-3 rounded text-sm">
          <div className="font-bold mb-2">å‡¡ä¾‹</div>
          <div className="flex items-center mb-1"><span className="w-4 h-4 mr-2 bg-[#e0e0e0] border border-gray-300"></span>åºŠ (LDKãªã©)</div>
          <div className="flex items-center mb-1"><span className="w-4 h-4 mr-2 bg-[#aaccff] border border-gray-300"></span>æ°´å›ã‚Š</div>
          <div className="flex items-center mb-1"><span className="w-4 h-4 mr-2 bg-[#eeeeee] border border-gray-400"></span>å£</div>
          <div className="flex items-center mb-1"><span className="w-4 h-4 mr-2 bg-[#8B4513] border border-gray-300"></span>å®¶å…·ãƒ»å»ºå…·</div>
          <div className="flex items-center mb-1"><span className="w-4 h-4 mr-2 bg-[#87CEEB] border border-gray-300"></span>çª“</div>
        </div>
      </div>
    </div>
  );
};

export default FloorPlanViewer3D;
